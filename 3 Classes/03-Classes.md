# 3. Object-Oriented Kotlin Programming

<!--suppress CheckImageSize -->
<img src="../images/Logo.png" width="300" alt="">

## Introduction

Classes in Kotlin work very similar to classes in Java but have some significant syntactic differences. For example, the `new` operator for object creation has been dropped in favour of using a syntax that makes object creation look like a factory function call.

This section will not focus on object-oriented programming and assumes a basic understanding of the concepts of class definitions, instantiating objects, visibility modifies and other related fundamental concepts.

This section will be based on the Kotlin [classes and object documentation](https://kotlinlang.org/docs/classes.html)

## Object Invariants

Classes are data abstractions with internal representations (often called fields or properties) and methods for interacting with them.

`Class invariants` are used to put some constraints on fields.
- For instance, for a Date field, the value representing the day should have values between 1 and 31.
- Every class implementation should guarantee that invariants are maintained.
- Invariants ensure that when a field is initialized, modified or updated, the resulting value is meaningful (like avoiding dates like March 32, -2034)

By contrast, if the day field is public (that is, if it can be accessed directly), we cannot verify its value when updated. This means exposing public fields can be nasty. But at the same time, some programming languages may not provide us with access modifiers.

For more on this idea, check out [design by contract](https://en.wikipedia.org/wiki/Design_by_contract)

## Encapsulation

[Kotlin Documentation](https://kotlinlang.org/docs/visibility-modifiers.html)

Support for encapsulation requires certain mechanisms for hiding the state (properties) and methods from the outside world.

Most languages provide access modifiers – e.g. public and private, where public means accessible by everyone and private means accessible only inside the class.

There are four access modifiers in Kotlin. In addition to `private` and `public` there are also:
- `protected` – Similar to private, but it allows access to a property/method inside both the class and its inheritors
- `internal` – Visible inside the module. The visibility modifier is related to a project structure.


## Types of Classes

In Java, classes are `public` or have a default package scope. In addition, Java classes can be declared `final` which means they cannot serve as a superclass for inheritance, and `abstract` meaning that objects could not be instantiated from the class definition.

#### Open and Final Classes

By default, classes in Kotlin are final. To allow subclassing, a Kotlin class must be declared `open`. The `final` modifier can be use but Kotlin will flag the usage as redundant

#### Abstract Classes

As in Java, objects cannot be instantiated from an `abstract` class. Since the purpose of an abstract class is to provide a common superclass for multiple subclasses, the `abstact` modifier automatically makes the class `open` without having to use the modifier `open`. In fact, if you try and declare a class to be `open abstract` Kotlin will remind you that the `open` is redundant.

Of course, trying to declare an abstract class final will produce a compile time error since there is no point to a class that you can't instantiate objects from nor create subclasses from

```kotlin

package demo_3_1

// Abstract, final and open class

class Base {
    fun writeout() {
        println("This is the Base class")
    }
}

open class OpenBase {
    fun writeout() {
        println("This is the OpenBase class")
    }
}


// Subclassing "Base" is a compiler error
//class newBase : Base() {}
// Subclassing "OpenBase" is not
class NewBase : OpenBase() {}

//--------------------------------

abstract class AbstractClass {
    fun writeout() {
        println("This is the AbstractClass class")

    }
}

class ConcreteClass : AbstractClass() {}

fun main() {
    val base = Base()
    base.writeout()

    val openBase = OpenBase()
    openBase.writeout()

    val newBase = NewBase()
    println("NewBase")
    newBase.writeout()

    // This is a compiler error
    //val abstractClass = AbstractClass();

    val concreteClass = ConcreteClass();
    concreteClass.writeout()
}
```
```shell
This is the Base class
This is the OpenBase class
NewBase
This is the OpenBase class
This is the AbstractClass class

```
---

## Implicit Classes

As mentioned before, functions and variables can be defined at the top level of a package and do not need to be defined as members of a class. However, this organization of code at the source level is compiled into classes that are generated by the Kotlin compiler.

In the demo below, there are two files `Main.kt` and `Other.kt` in the same package `work`.

First, consider the `Other.kt` file

```kotlin
package demo_3_2
// Demo 3.2 Program Structure
// Other.kt file

// this is visible in all files in package work
val alternateGreeting = "Go Away!!!"

// this is visible ONLY in this file
private val rudeGreeting = "You must be a PHP programmer"

// This can access the rudeGreeting variable since it is in the same file
fun goAway() {
    println(rudeGreeting)
}
```

And the `Main.kt` file

```kotlin
package demo_3_2
// Demo 3.2 Program Structure

// Main.kt file
// Note that the variable alternateGreeting is defined in another file
// Other.kt in the same package work

val greeting = "Hello World"

fun main() {
    println(greeting)  // top level variable in this file/package
    println(alternateGreeting) // top level variable in Other.kt
    // println(rudeGreeting) // not allowed: private top level variable in another file
    goAway()  // top level function in Other.kt
}
```
Which produces the output

```shell
Hello World
Go Away!!!
You must be a PHP programmer

Process finished with exit code 0

```
#### Implementation Details

Package-level functions and variables are implemented as static methods and fields in generated classes by the Kotlin compiler. This cleans up a lot of the old syntactic clutter required when using static methods and fields in Java.

For example, if the class file generated from `Other.kt` and `Main.kt` were decompiled from Java bytecode they would look something like this

First the `Other.kt` file


```java
// Decompiled from OtherKt.class
package demo_3_2;

public final class OtherKt {
    private static final String greeting = "Hello World";
    private static final String rudeGreeting = "You must be a PHP programmer";

    public static void goAway() {
        System.out.println( OtherKt.rudeGreeting);
    }
}
```
And `Main.kt`

```java
// Decompiled from OtherKt.class
package demo_3_2;

public final class MainKt {
    private static final String alternateGreeting = "Go Away!!!";
    
    public static void main (String[] args) {
        System.out.println( MainKt.greeting);
        System.out.println( MainKt.greeting);
    }
}

```

## Constructors

Kotlin constructors are a similar to Java constructors with some significant differences.

The `new` operator is eliminated so that constructor calls now look more like regular function calls.

This is carried over into the way constructors are defined in the class definition. The class definition is written in a way that looks like a function definition. The problem is that there is no place to put the body of the constructor. The solution is to have something called an `init` block that contains the body of the constructor.

Consider the rather simple Java class: (ignore the encapsulation issues)

```java
public class Person {
    String name;

    // Constructor
    public Person(String name) {
        this.name = name;
    }
}

```

This could be written in Kotlin in several different ways.

Notice that there is no need to explicitly declare fields since they are created implicitly just like local variables in a function call.

```kotlin
class Person(val name: String)
//or
class Person constructor(val name: String)

class Person (val name: String) {
    // more tra
}
```

If we wanted to implement constraints on name, like providing a default value to replace an empty string, we would have to implement this in an init block.  We can have as many init block as we want, but they are all executed right after the constructor is called.

```kotlin
package demo_3_3

class Person(val name: String)

class Person2 constructor(var name: String) {
    val counter = 1
    init {
        if (name == "") {
            name = "Unknown"
        }
        println("This is the first init block")
    }

    init {
        println("This is the second init block")
    }
}

fun main() {
    val bob = Person("Robert")
    val ted = Person2("Theodore")
    val igor = Person2("")

    println("bob's name is ${bob.name}")
    println("ted's name is ${ted.name}")
    println("igor's name is ${igor.name}")
}
```
```shell
This is the first init block
This is the second init block
This is the first init block
This is the second init block
bob's name is Robert
ted's name is Theodore
igor's name is Unknown
```

### Explicit initialization

In the example above, the use of the `val` keyword in the constructor implicitly creates the field. However, if we omit this keyword or others like `var`, the constructor only passes local variables, and we have to define our fields like we do in Java.

```kotlin
package demo_3_4

class Person(name:String) {
    var myName: String

    init{
       this.myName = name.uppercase()
    }
}

class Person2(name:String) {
    val myName =  name.uppercase()

}

fun main() {
    val bob = Person("Robert")
    val ted = Person2("Theodore")
    println("bob's name is ${bob.myName}")
    println("ted's name is ${ted.myName}")
    // compile error since
   // println("bob's name is ${bob.name}")
}
```
```shell
bob's name is ROBERT
ted's name is THEODORE
```

### Secondary Constructors

The constructor defined above is called the `primary constuctor`, but Kotlin, like Java, allows for other constructors. Constructors in a Kotlin class

Kotlin recommends that the effect of multiple constructors can be implemented by using default arguments


```kotlin
package demo_3_5

// Demo 3.5

class Person(val myName:String = "Unknown")

fun main() {
    val bob = Person("Robert")
    val ted = Person()

    println("bob's name is ${bob.myName}")
    println("ted's name is ${ted.myName}")
}
```
```shell
bob's name is Robert
ted's name is Unknown
```

Other constructors can be defined using the prefix constructor in order to overload the constructor operation.
- The primary constructor must be executed first by having the secondary constructor make a call using `this()` before executing the body of the secondary constructor
- The secondary constructor may call another secondary constructor instead of the primary constructor directly it may call another secondary constructor, but this chain of calls must terminate with a call to the primary constructor.
- This is demonstrated in Demo 3.6

```kotlin
package demo_3_6

class Person(var myName:String, var age:Int ) {
    init {
        println("Executing primary constructor block")
        if (age < 0) this.age = 0
    }

    constructor(name: String) : this(name,0) {
        println("Executing one argument constructor")
    }

    constructor() : this("Unknown") {
        println("Executing no argument constructor")
    }
}

fun main() {
    val bob = Person("Robert", 32)
    println("------ bob's name is ${bob.myName} my age is ${bob.age}")
    val ted = Person("Theodore")
    println("------ ted's name is ${ted.myName} my age is ${ted.age}")
    val anon = Person()
    println("------ anon's name is ${anon.myName} my age is ${anon.age}")

}
```
```shell
Executing primary constructor block
------ bob's name is Robert my age is 32
Executing primary constructor block
Executing one argument constructor
------ ted's name is Theodore my age is 0
Executing primary constructor block
Executing one argument constructor
Executing no argument constructor
------ anon's name is Unknown my age is 0
```

### Default Constructors

If a class has no constructors defined, as in Java, a default constructor is generated that takes no arguments.
- This contractor will execute any init blocks defined in the class
- As in Java, defining any other constructors will remove the default constructor
- This constructor can be disabled by making it private


```kotlin
package demo_3_7

class Thing {
    init {
        println("Init block")
    }
}

class PrivateThing private constructor()

fun main() {
    val thing = Thing()
    // Compiler error
    //val privateThing = PrivateThing()
}
```
```shell
Init block
```

## Properties

[Kotlin Documentation](https://kotlinlang.org/docs/properties.html)

Properties are the term referred to the instance variables that represent some sort of value that is generally exposed in some way to other objects.

- Properties in Kotlin automatically come with getter and setter functions, even if they are not explicitly defined
- When a property is declared using `var`, Kotlin automatically generates a getter and a setter for you. If `val`, it generates only a getter, making the property read-only.

### Default Getters and Setters

If you don't supply a custom getter or setter for a field, then defaults are generated. If the property is immutable, only a default getter is created. The logic of the defaults is the same as if you wrote a standard getter or setter in Java.

### Custom getters and setters

Custom getter and setters can be defined as show in Demo 3.8

```kotlin
package demo_3_8

class Rect(w: Double, h: Double) {
    var height :Double = if (h > 0.0) h else throw IllegalArgumentException("Height must be greater than 0")
        get() {
            println("-----Height getter")
            return field
        }
        set(h) {
            println("-----Height setter")
            if (h <= 0.0)  throw IllegalArgumentException("Height must be greater than 0")
            field = h
        }
    var width: Double = if (w > 0.0) w else throw IllegalArgumentException("Width must be greater than 0")

    val area
        get() = this.height * this.width



}

fun main() {
    val r = Rect(1.0,1.0)
    println("The height is ${r.height}")
    println("The width is ${r.width}")
    println("The area is ${r.area}")
    r.height = 4.0
    println("The height is ${r.height}")
    println("The area is ${r.area}")

}
```
```shell
-----Height getter
The height is 1.0
The width is 1.0
-----Height getter
The area is 1.0
-----Height setter
-----Height getter
The height is 4.0
-----Height getter
The area is 4.0
```

## Inheritance

[Kotlin Documentation](https://kotlinlang.org/docs/inheritance.html)

### Using Constructors

The following are examples of calling the base class constructors.

```kotlin
package demo_3_9

// Demo 3.9

// Base class with a primary constructor
open class BaseClass(val name: String)

// Derived class with a primary constructor that initializes the base class
class DerivedClass(name: String, val age: Int) : BaseClass(name) {
    fun printInfo() {
        println("Name: $name, Age: $age")
    }
}

fun main() {
    val derived = DerivedClass("Alice", 25)
    derived.printInfo()  // Output: Name: Alice, Age: 25
}
```
```shell
Name: Alice, Age: 25
```

```kotlin
package demo_3_9a

// Base class with two constructors
open class BaseClass {
    val name: String

    constructor(name: String) {
        this.name = name
        println("Base class constructor with name: $name")
    }

    constructor(name: String, age: Int) {
        this.name = "$name (Age: $age)"
        println("Base class constructor with name and age: $name, $age")
    }
}

// Derived class with two secondary constructors
class DerivedClass : BaseClass {

    // First secondary constructor: initializes base class directly
    constructor(name: String) : super(name) {
        println("Derived class constructor with name: $name")
    }

    // Second secondary constructor: delegates to another constructor
    constructor(name: String, age: Int) : this(name) {
        println("Derived class constructor with name and age: $name, $age")
    }
}

fun main() {
    val derived1 = DerivedClass("Bob")
    println("-----------")
    val derived2 = DerivedClass("Charlie", 30)
}
```shell
Base class constructor with name: Bob
Derived class constructor with name: Bob
-----------
Base class constructor with name: Charlie
Derived class constructor with name: Charlie
Derived class constructor with name and age: Charlie, 30```shell

```

### Overriding methods and properties

[Kotlin Documentation](https://kotlinlang.org/docs/inheritance.html)

```kotlin
package demo_3_10


open class Shape {
    open fun draw() {
        println("Shape draw")
    }  // removing open creates an error
    open val vertexCount: Int = 0
    fun fill() { /*...*/ }
}

open class Rectangle() : Shape() {
    override val vertexCount = 4
    override fun draw() {
        println("Rectangle draw")
    }  // removing override is an error
}

class Box() : Rectangle() {
    override fun draw() {
       // super.draw()
        println("Box draw")
    }

}

fun main() {
    val b = Box()
    println("Vertices = ${b.vertexCount}")

    b.draw()
}
```
```shell
Vertices = 4
Rectangle draw
Box draw
```

## Interfaces

[Kotlin Documentation](https://kotlinlang.org/docs/interfaces.html)

Interfaces work in a very similar way to how Java Interfaces work

Properties do not necessarily have a backing field so they can be defined in an interface as long as a backing field is not required.

```kotlin
package demo_3_11

interface Named {
    val firstName: String
    val lastName: String
    val name: String
}

class Employee(f:String, l:String) : Named {
    // implementing 'name' is not required
    override val firstName: String = f
    override val lastName: String = l
    override val name: String get() = "$firstName $lastName"
}

fun main() {
    val bob = Employee("Bob", "Smith")
    println(bob.name)
}
```
```shell
Bob Smith
```
---

## Visibility Modifiers

[Kotlin Documentation](https://kotlinlang.org/docs/visibility-modifiers.html)

These behave fundamentally the same as in Java and other OO languages.

---


## Extension functions

The primary reason for using extension functions is to extend the functionality of existing classes without modifying their source code or inheriting from them. 

This allows you to add new functions to classes that you don't own or can't change, making the code more expressive and readable.

#### Key Benefits of Extension Functions:
- Enhance Existing Classes: allow adding utility methods to existing classes, including classes from third-party libraries or the standard library, without altering their original implementation.
- Improved Readability: enable more fluent and natural code by calling the new function directly on instances of the class, as if it were part of the original API.
- Maintainability: Since is no reason to modify the original class or create a subclass to add functionality, the code remains cleaner and easier to maintain. Related code can be kept together without the need for extensive refactoring.
- Better Code Organization: group related functionality together in extension functions, keeping the codebase organized and avoiding cluttering the original class with methods that may not be universally useful.
- Increased Reusability: can be easily reused across project. They can be defined in one place and used  wherever the extended functionality is needed

```kotlin 
package demo_3_12

fun String.isPalindrome(): Boolean {
    return this == this.reversed()
}

fun main() {
    val word = "madam"
    println("Is '$word' a palindrome? ${word.isPalindrome()}")
}
```
```shell
Is 'madam' a palindrome? true
```

---

## Data classes

A data class in Kotlin is a special type of class designed to hold data. It automatically provides several useful features, such as equals(), hashCode(), toString(), copy(), and component functions for destructuring declarations, all without needing to write much boilerplate code.

```kotlin
package demo_3_13

data class Person(val name: String, val age: Int, val email: String)

fun main() {
    // Creating an instance of the Person data class
    val person1 = Person(name = "John Doe", age = 30, email = "johndoe@example.com")

    // Automatically generated toString() method
    println("Person Details: $person1")

    // Automatically generated equals() and hashCode() methods
    val person2 = Person(name = "John Doe", age = 30, email = "johndoe@example.com")
    println("Are person1 and person2 equal? ${person1 == person2}")
    println("Hashcode of person1 ${person1.hashCode()} of person2 ${person2.hashCode()}")

    // Copying an instance with modification
    val person3 = person1.copy(age = 31)
    println("Copied Person with modified age: $person3")
    println("Hashcode of person3 ${person3.hashCode()}")

    // Destructuring declaration
    val (name, age, email) = person1
    println("Name: $name, Age: $age, Email: $email")
}
```
```shell
Person Details: Person(name=John Doe, age=30, email=johndoe@example.com)
Are person1 and person2 equal? true
Hashcode of person1 -1066114157 of person2 -1066114157
Copied Person with modified age: Person(name=John Doe, age=31, email=johndoe@example.com)
Hashcode of person3 -1066114126
Name: John Doe, Age: 30, Email: johndoe@example.com
```

---

## Sealed Classes

A sealed class is a special type of class that restricts which classes can inherit from it. 
- Sealed classes are used to represent a closed set of possible types, ensuring that all subclasses are known and controlled. 
- They are particularly useful in scenarios where there is a need to model a specific number of variants, making the code more robust and easier to manage.

#### Key Features of Sealed Classes:

- Restricted Inheritance with Package Scope: All subclasses of a sealed class must be declared in the same package as the sealed class. This ensures that no other subclasses can be created outside of this defined package, giving control over the class hierarchy while allowing code to span across multiple files.
- Exhaustive `when` Expressions: Using a `when` expression with a sealed class, the compiler can check if all possible cases (subclasses) are handled. This helps ensure that the code is robust and not missing any cases, which could lead to runtime errors.
- Encapsulation of State: Sealed classes are often used to represent states or different variants of a type, making them a powerful tool for handling scenarios like UI states, network results, or domain-specific models.

```kotlin
package demo_3_14

sealed class NetworkResult

data class Success(val data: String) : NetworkResult()
data class Error(val exception: Exception) : NetworkResult()
object Loading : NetworkResult()

fun handleNetworkResult(result: NetworkResult) {
    when (result) {
        is Success -> println("Data received: ${result.data}")
        is Error -> println("Error occurred: ${result.exception.message}")
        is Loading -> println("Loading data...")
    }
}

fun main() {
    val successResult = Success("Hello, World!")
    val errorResult = Error(Exception("Network failure"))
    val loadingResult = Loading

    handleNetworkResult(successResult)
    handleNetworkResult(errorResult)
    handleNetworkResult(loadingResult)
}

```
```shell
Data received: Hello, World!
Error occurred: Network failure
Loading data...


```

---

## Generics

[Kotlin Documentation](https://kotlinlang.org/docs/generics.html)

Generics in Kotlin behave much like generics in Java. We will avoid the intricate discussion of the replacement for Java wildcards

---

## Specialized Classes

These will just be reviewed quickly in class


---

## End Module
